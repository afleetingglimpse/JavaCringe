На мысль изучить подобные алгоритмы натолкнула задача https://leetcode.com/problems/jump-game-iv/ 

Вкратце она состоит в следующем. 
Дан массив, переходы между элементами которого разрешены при условиях:
i -> i + 1 where: i + 1 < arr.length.
i -> i - 1 where: i - 1 >= 0.
i -> j where: arr[i] == arr[j] and i != j.
Return the minimum number of steps to reach the last index of the array.

Можно было представить массив в виде графа, но я решил написать алгоритм, который принимал бы в качестве параметра не граф, 
а простой список, переходы между элементами которого определялись бы интерфейсом Function<List<T>, T>. Также нужно было 
создать условие досрочного выхода из обхода списка при определенном условии. Это было реализовано интерфейсом Predicate<T> 
(в данном случае это функция, возвращающая true если indexOf(T) == arr.length - 1. 
